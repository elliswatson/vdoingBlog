(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{400:function(t,e,s){t.exports=s.p+"assets/img/image-20230826094808465.a53e4aaa.jpg"},401:function(t,e,s){t.exports=s.p+"assets/img/image-20230826100237601.421d2ce2.jpg"},402:function(t,e,s){t.exports=s.p+"assets/img/image-20230826100743306.7a4ffd99.jpg"},403:function(t,e,s){t.exports=s.p+"assets/img/image-20230826102202379.73c2f07d.jpg"},468:function(t,e,s){"use strict";s.r(e);var a=s(11),l=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"malloc-vs-new"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#malloc-vs-new"}},[t._v("#")]),t._v(" malloc vs new")]),t._v(" "),e("p",[t._v("先写一个简单的malloc测试函数：")]),t._v(" "),e("img",{staticStyle:{width:"100%"},attrs:{src:s(400)}}),t._v(" "),e("p",[t._v("第一条指令，把数值4赋给寄存器edi,很显然：这是为后面的函数调用，准备参数，第二条指令就是调用函数malloc,结合传入的参数4，我们可以很容易猜出，这是要申请一个4字节大小的内存块，这样看来malloc是一个非常单纯的函数，输入所需内存的大小，它就可以帮我们申请相应大小的内存块，让我们再看看malloc的同门兄弟：new")]),t._v(" "),e("p",[t._v("先编写一个最简单的类：A,然后写一个简单的函数用来申请一个类A的对象")]),t._v(" "),e("img",{staticStyle:{width:"100%"},attrs:{src:s(401)}}),t._v(" "),e("p",[t._v("虽然new只有一行代码，却生成了4条指令，它们除了样子怪了一点并没有什么过人之处，先看前两条指令：和调用malloc非常相似，第一条指令还是传递参数值8，因为类A仅有两个int类型的成员变量，所以类A的大小是8个字节，非常合理，然后就是调用一个operator new 的函数，如此逆天的名字，真的让人怀疑自己的知识储备，但在cpu眼里，它根本就不是一个名字，而是一个函数首地址而已，当然不是我们写的函数，而是操作系统提前为为我们预备好的内存分配函数，当然也可以自己重写这个函数，至此内存分配就完成了")]),t._v(" "),e("img",{staticStyle:{width:"100%"},attrs:{src:s(402)}}),t._v(" "),e("p",[t._v("如果是malloc，就可以收工了，但new可不行，别忘了，类对象是需要初始化的，就是要调用构造函数，所以剩下的两条指令也很好解释了，第三条指令就是传递this指针")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v(" mov     rdi, rax\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("第四条就是调用类A的构造函数，")]),t._v(" "),e("p",[t._v("真不愧是C++,如此简单的一个单词，竟然包含如此多的信息。")]),t._v(" "),e("p",[t._v("同上，我们可以很容易的猜出：free和delete之间的差异，")]),t._v(" "),e("p",[t._v("free是malloc的反向操作，也是一个纯函数接口，不过它的用途不是申请内存，而是释放，归还刚才申请的内存，")]),t._v(" "),e("img",{staticStyle:{width:"100%"},attrs:{src:s(403)}}),t._v(" "),e("p",[t._v("同样delete是new的反向操作，包含两个操作，首先调用类A的析构函数，然后就可以释放，归还类A对象所占据的内存空间。")]),t._v(" "),e("p",[e("strong",[t._v("总结")])]),t._v(" "),e("p",[e("strong",[t._v("1.malloc和free都是单纯的函数，用来申请和归还内存。")])]),t._v(" "),e("p",[e("strong",[t._v("2，new包含了两个操作，第一个操作和malloc类似，也是申请内存，第二个操作也就是对类A的对象进行初始化，就是调用类A的构造函数，至于delete则正好相反，")])]),t._v(" "),e("p",[e("strong",[t._v("3.无论是malloc和new,它们都是可以被“重载”的。")])]),t._v(" "),e("p",[e("strong",[t._v("4.系统提供的malloc和new都会从堆上申请内存，但如果自己重载了malloc和new，那到底从哪里申请内存，就全靠自己把握了。")])])])}),[],!1,null,null,null);e.default=l.exports}}]);