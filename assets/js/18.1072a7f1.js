(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{394:function(t,s,a){t.exports=a.p+"assets/img/image-20230825162049898.00825001.jpg"},395:function(t,s,a){t.exports=a.p+"assets/img/image-20230825162132821.589a1a96.jpg"},396:function(t,s,a){t.exports=a.p+"assets/img/image-20230825164059427.63f5faf0.jpg"},466:function(t,s,a){"use strict";a.r(s);var i=a(11),e=Object(i.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"volatile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[t._v("#")]),t._v(" volatile")]),t._v(" "),s("img",{staticStyle:{width:"%100"},attrs:{src:a(394)}}),t._v(" "),s("p",[t._v("对代码进行2级优化 -Ofast")]),t._v(" "),s("img",{staticStyle:{width:"%100"},attrs:{src:a(395)}}),t._v(" "),s("p",[t._v("....13条指令立马变成了5条，while循环都没有了，直接返回0，原来编译器会把变量a当常量来对待，既然是常量，那么a和1的比较结果是预先可知的，while条件不满足，显然可以不用执行，所以自然就被编译器优化掉了，这看上去也很合理，最后让我们给变量a加上修饰符volatile,有趣的事情发上了，while的三条指令有回来了")]),t._v(" "),s("img",{staticStyle:{width:"%100"},attrs:{src:a(396)}}),t._v(" "),s("p",[t._v("现在明白volatile的真正含义了嘛？易变不是讲给程序员听的，而是告诉编译器听的，原来编译器会把不会改变的变量当常量对待，以此换取大幅度的优化，缩减汇编指令，而volatile则是阻止这种优化，让CPU老老实实从内存中读写变量，")]),t._v(" "),s("p",[s("strong",[t._v("结论：谨慎使用优化，或使用统一，一致的编译器，并确保各个软件版本的优化等级一致就显的非常必要了。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);