(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{377:function(s,t,a){s.exports=a.p+"assets/img/image-20230824165133543.a72bd21f.jpg"},378:function(s,t,a){s.exports=a.p+"assets/img/image-20230824165614147.c526bd91.jpg"},379:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170002746.5794abb1.jpg"},380:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170257522.7168946c.jpg"},381:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170436677.06eb63d2.jpg"},382:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170732419.c94100c1.jpg"},383:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170932235.2bf367a5.jpg"},384:function(s,t,a){s.exports=a.p+"assets/img/image-20230824170957578.756847b6.jpg"},385:function(s,t,a){s.exports=a.p+"assets/img/image-20230824171140934.7efd6eca.jpg"},386:function(s,t,a){s.exports=a.p+"assets/img/image-20230824171552496.34efcf86.jpg"},461:function(s,t,a){"use strict";a.r(t);var n=a(11),p=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h3",{attrs:{id:"函数调用-调用栈回溯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数调用-调用栈回溯"}},[s._v("#")]),s._v(" 函数调用|调用栈回溯")]),s._v(" "),t("p",[s._v("IDE是如何回溯出调用轨迹的，操作系统会为每一个线程准备一段内存，专门用来记录该线程的：函数调用轨迹，")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(377)}}),s._v(" "),t("p",[s._v("为方便展示，下方为高地址，上方为低地址，然后用一根水位线表述该内存的使用量")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(378)}}),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("func_2():\n        push    rbp\n        mov     rbp, rsp\n        mov     eax, 3\n        pop     rbp\n        ret\nfunc_1():\n        push    rbp\n        mov     rbp, rsp\n        call    func_2()\n        pop     rbp\n        ret\nmmain():\n        push    rbp\n        mov     rbp, rsp\n        call    func_1()\n        pop     rbp\n        ret\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br")])]),t("p",[s._v("首先从main函数开始，第一条push指令，把rbp寄存器的值存入内存，具体值并不重要就用rbp-main标识一下好了")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(379)}}),s._v(" "),t("p",[s._v("mov指令对内存无影响可略过，call指令会把下一条指令的地址存入内存，然后cpu跳转到函数1继续执行，函数1的push指令会用push指令将rbp寄存器的值存入内存，mov 可略过，")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(380)}}),s._v(" "),t("p",[s._v("call会将下一条指令存入内存，然后cpu跳转到func2继续执行")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(381)}}),s._v(" "),t("p",[s._v("善始善终，我们再看看返回过程")]),s._v(" "),t("p",[s._v("越过两条mov指令，pop指令会把水位线上的值赋给rbp,ret会把水位线上的值赋给寄存器rip,从而让rip引导cpu返回到func_1")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(382)}}),s._v(" "),t("p",[s._v("返回到func1后，把水位线上的值赋给：寄存器rbp,")]),s._v(" "),t("p",[t("img",{staticStyle:{width:"100%"},attrs:{src:a(383)}}),s._v("ret指令则把水位线上的值赋给寄存器rip")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(384)}}),s._v(" "),t("p",[s._v("让rip引导cpu返回到main函数，回到main函数后，越过nop指令，随后的pop指令会把水位线上的值赋给寄存器rbp")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(385)}}),s._v(" "),t("p",[s._v("至此，所有的函数调用结束，水位线有落回到了起点，内存完璧归赵；一点没多一点没少。")]),s._v(" "),t("p",[s._v("现在知道为什么这块内存叫堆栈了吧！因为它的存储方式是堆叠的，这里的水位线也就是大家常说的栈顶，")]),s._v(" "),t("img",{staticStyle:{width:"100%"},attrs:{src:a(386)}}),s._v(" "),t("p",[s._v("就保存在rsp寄存器里面。")]),s._v(" "),t("p",[t("strong",[s._v("总结")]),s._v("：")]),s._v(" "),t("p",[s._v("​\t"),t("strong",[s._v("1.堆栈是一段普通的内存，每次函数调用都需要使用一定数量的内存，用来存放返回地址和其他信息，")])]),s._v(" "),t("p",[s._v("​\t"),t("strong",[s._v("2.每次函数的返回都会如数返还刚才调用时所占用的内存，但不会清理数据")])]),s._v(" "),t("p",[s._v("​\t**3.如果函数嵌套调用过深，函数一直没有机会返回，并释放占用的内存，就可能出现水位线超标的现象，也就是所谓的堆栈溢出，**最典型的例子就是无穷递归，不得不佩服使用堆栈的设计方法，巧妙的解决了函数调用，返回等诸多问题，更是实现了程序运行效率和空间上的双丰收，当然堆栈不仅可以存放函数返回地址，还能存放参数，栈变量和其他数据。这也是每次函数调用都要存储，恢复rbp寄存器的原因")]),s._v(" "),t("p",[s._v("既然知道了函数调用的原理，手动回溯出完整的调用轨迹，就简单了，通过一个栈变量获得栈顶位置(栈顶的内存地址)，然后使用万能的指针操作遍历一段堆栈数据，再根据代码段的地址特性做一下过滤，配合map表一个完整的函数调用轨迹就出来了")]),s._v(" "),t("p",[s._v('![image-20230824174635238](./../.vuepress/public/img/CPLUS/image-20230824174635238.jpg" style="width:100%" />')])])}),[],!1,null,null,null);t.default=p.exports}}]);