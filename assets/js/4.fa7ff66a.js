(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{368:function(t,s,i){t.exports=i.p+"assets/img/image-20230825094824605.f965b2ef.jpg"},369:function(t,s,i){t.exports=i.p+"assets/img/image-20230825095200970.ff1903c9.jpg"},370:function(t,s,i){t.exports=i.p+"assets/img/image-20230825095702124.f81cdf01.jpg"},371:function(t,s,i){t.exports=i.p+"assets/img/image-20230825100320357.c2b428b1.jpg"},372:function(t,s,i){t.exports=i.p+"assets/img/image-20230825100607741.996243a1.jpg"},373:function(t,s,i){t.exports=i.p+"assets/img/image-20230825100724821.c171a018.jpg"},374:function(t,s,i){t.exports=i.p+"assets/img/image-20230825101113832.418ce19d.jpg"},375:function(t,s,i){t.exports=i.p+"assets/img/image-20230825101511058.6f825464.jpg"},376:function(t,s,i){t.exports=i.p+"assets/img/image-20230825101610427.2d3bb500.jpg"},460:function(t,s,i){"use strict";i.r(s);var e=i(11),p=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"函数括号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数括号"}},[t._v("#")]),t._v(" 函数括号")]),t._v(" "),s("p",[t._v("在我们写过无数个函数后，是否会考虑一个问题？当我们在函数中一顿神操作后为什么函数返回后一切恢复如初？刚刚定义的临时变量去了哪里？答案就是写了无数次的{}，这中灵魂操作很少有人提及，毫无存在感，今天我们从cpu视角来看看这个灵魂操作。")]),t._v(" "),s("p",[t._v("​\t\t打开compiler explorer 编写一个简单的函数和一个函数调用，")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(368)}}),t._v(" "),s("p",[t._v("函数之间能随意调用还能顺利收场，就完全仰仗他们了，")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(369)}}),t._v(" "),s("p",[t._v("假设这段内存是当前任务的堆栈，为了方便展示堆叠结构，下面是高端地址，上面是低端地址")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(370)}}),t._v(" "),s("p",[t._v("初始栈帧是main函数的栈帧，在红蓝两条线之间，红色用来标识栈顶地址esp的值，蓝色用来标识栈基ebp的值，用来标识main函数栈帧基地址。不用关心main函数的栈帧，一切从函数func开始，首先执行第一条指令将ebp压入栈顶，栈顶水位线也随之升高")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(371)}}),t._v(" "),s("p",[t._v("main函数的栈帧保护工作完成，然后通过mov指令更新一下栈帧基准线，让它与栈顶水位线齐平，")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(372)}}),t._v(" "),s("p",[t._v("通过sub指令将红色水位线上升8个字节，")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(373)}}),t._v(" "),s("p",[t._v("随后就是对临时变量a,b赋值，a,b相对于蓝色基准线的偏移刚好是4和8，正好用玩函数的栈帧，一点不多，一点不少，好了，函数执行完是该恢复main函数的栈帧了，")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(374)}}),t._v(" "),s("p",[t._v("通过mov指令将红色水位线先降低至蓝色基准线位置，然后通过pop指令把事先压入栈顶的ebp值，返还给寄存器ebp,这样蓝色基准线又恢复到了最开始的位置。")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(375)}}),t._v(" "),s("p",[t._v("同时随着栈顶的下降，红色基准线也随之下降")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:i(376)}}),t._v(" "),s("p",[t._v("至此，main函数的栈帧恢复完成，不准确的说，函数的栈帧就是红蓝两条线之间的内存块，它用来存放函数的临时变量，参数和返回地址。所谓的保存或者恢复栈帧，不过是在变更ebp和esp的值。")]),t._v(" "),s("p",[s("strong",[t._v("总结：")])]),t._v(" "),s("p",[s("strong",[t._v("1.操作系统会为每个任务分配一段内存，当作任务堆栈，cpu会提供两个寄存器esp和ebp用来标识当前堆栈的使用情况，随着函数的调用，函数的栈帧会逐次堆叠，互不重合，随着函数的逐次返回，函数的栈帧会：被就地放弃，但不会清理内存。")])]),t._v(" "),s("p",[s("strong",[t._v("2.正括号用来保护上层主调函数的栈帧，并设置被调函数的栈帧，反括号用来放弃被调函数的栈帧，同时恢复主调函数的栈帧，这样被调函数执行完后，主调函数就会继续执行。、")])]),t._v(" "),s("p",[s("strong",[t._v("3.ebp寄存器作为当前函数的栈帧基地址，配合一定的偏移就可以读写函数体力的临时变量，如果一个变量是通过ebp寄存器间接访问的，它往往是临时变量，也叫栈变量，")])]),t._v(" "),s("p",[s("strong",[t._v("4.不同编译器对栈帧的实现方法略有不同，但思路一致。")])])])}),[],!1,null,null,null);s.default=p.exports}}]);