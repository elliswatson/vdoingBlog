(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{340:function(t,s,a){t.exports=a.p+"assets/img/image-20230816213237149.4a402993.jpg"},341:function(t,s,a){t.exports=a.p+"assets/img/image-20230816214807086.78e21df2.jpg"},342:function(t,s,a){t.exports=a.p+"assets/img/image-20230816221018660.a2add23c.jpg"},343:function(t,s,a){t.exports=a.p+"assets/img/image-20230816222132551.e110cc3a.jpg"},344:function(t,s,a){t.exports=a.p+"assets/img/image-20230816222843173.7222f1f5.jpg"},345:function(t,s,a){t.exports=a.p+"assets/img/image-20230816224702515.dcb4e50f.jpg"},453:function(t,s,a){"use strict";a.r(s);var r=a(11),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"虚函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚函数"}},[t._v("#")]),t._v(" 虚函数")]),t._v(" "),s("p",[t._v("​\t\t虚函数作为C++的重要特性，让人又爱又怕，爱它功能强大，但又怕驾驭不好，让它反咬一口，今天，我们就从CPU视角撕掉语法伪装。注：我们只比较指令的差异。")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(340)}}),t._v(" "),s("p",[t._v("显然两个函数完全一致，虚函数和普通函数没有任何区别，都会夹带this指针，如下代码表示this指针的入参")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("        mov     QWORD PTR [rbp-8], rdi\n        mov     rax, QWORD PTR [rbp-8]\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("让我们再看看调用他们有什么不同：")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(341)}}),t._v(" "),s("p",[t._v("可以看出普通的函数调用在编译阶段地址就已经确定了，就是所谓的静态绑定而虚函数的调用，call指令只能根据rdx寄存器的值来确定函数位置，也就是所谓的动态绑定。所谓的动态绑定也不过是下面三条指令而已：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("        mov     rax, QWORD PTR [rbp-8]\n        mov     rax, QWORD PTR [rax]\n        mov     rdx, QWORD PTR [rax]\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("有兴趣的小伙伴可以细品这三条指令。下面是等价代码：")]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(342)}}),t._v(" "),s("p",[s("strong",[t._v("结论：")])]),t._v(" "),s("p",[t._v("​\t\t"),s("strong",[t._v("当类A有虚函数的时候，类A就会偷偷生成一个隐藏成员变量，方便起见，我们为这个变量起一个名字：V（指针类型），V存放在虚函数表的地址，根据偏移就可以得到要执行的vfunc_1 的地址，将其存放在rdx寄存器里面，随后一条call rdx 指令，一个虚函数的调用就完成了。")])]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(343)}}),t._v(" "),s("p",[s("strong",[t._v("类的成员函数会夹带隐藏参数this指针，还能接受的话，那么类还会夹带隐藏变量V,你能接受吗？如果真的存在隐藏变量v,那么在哪里给V初始化呢？答案是在A的构造函数中，把V初始化成类A的虚函数表地址")])]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(344)}}),t._v(" "),s("p",[s("strong",[t._v("如上图，尽管我没有写构造函数，编译器还是会给我生成一个默认的构造函数，它一定必须帮我完成隐藏变量V的初始化。")])]),t._v(" "),s("p",[t._v("​\t\t"),s("strong",[t._v("当然如果类A有派生类B的话，隐藏变量V会在B的构造函数中被初始化为B的虚函数表地址，从而保证A和B的虚函数表相互独立，井水不犯河水，但考虑到派生类B还会调用基类A的构造函数，因此变量V一会儿被初始化为类A的虚函数表，一会儿被初始化为类B的虚函数表，为了避免晕头，往往禁止在构造函数中调用虚函数。")])]),t._v(" "),s("p",[s("strong",[t._v("总结：")])]),t._v(" "),s("p",[s("strong",[t._v("1.虚函数在虚函数体方面和普通函数没有任何区别，")])]),t._v(" "),s("p",[s("strong",[t._v("2，虚函数的调用，需要借助类对象的隐藏变量v(vptr)来完成，隐藏变量V会在构造函数中被初始化成虚函数表的内存地址，最后，调用任何虚函数的套路，都是一样的，唯一的区别是要根据他们在虚函数表的位置，设置正确的偏移量，")])]),t._v(" "),s("img",{staticStyle:{width:"100%"},attrs:{src:a(345)}}),t._v(" "),s("p",[t._v("不得不佩服虚函数的实现方法，虚函数的出现使指针的使用率大大降低。")])])}),[],!1,null,null,null);s.default=e.exports}}]);